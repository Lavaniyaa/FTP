// This file is automatically generated from ftpdemo.pac.


#ifdef __clang__
#pragma clang diagnostic ignored "-Wparentheses-equality"
#endif
#include <iostream>
#include "ftpdemo_pac.h"

using namespace std;


namespace binpac {

namespace FTPDEMO {

ContextFTPDEMO::ContextFTPDEMO(FTPDEMO_Conn * connection, FTPDEMO_Flow * flow)
	{
	connection_ = connection;
	flow_ = flow;
	}

ContextFTPDEMO::~ContextFTPDEMO()
	{
	}

FTPDEMO_Conn::FTPDEMO_Conn(click_ftp_info *info){
	upflow_ = new FTPDEMO_Flow(this, true);
	downflow_ = new FTPDEMO_Flow(this, false);
	info_ = info;
}
FTPDEMO_Conn::~FTPDEMO_Conn()
	{
	delete upflow_;
	upflow_ = 0;
	delete downflow_;
	downflow_ = 0;
	}

void FTPDEMO_Conn::NewData(bool is_orig, const_byteptr begin, const_byteptr end)
	{
	if ( is_orig )
		upflow_->NewData(begin, end);
	else
		downflow_->NewData(begin, end);
	}

void FTPDEMO_Conn::NewGap(bool is_orig, int gap_length)
	{
	if ( is_orig )
		upflow_->NewGap(gap_length);
	else
		downflow_->NewGap(gap_length);
	}

void FTPDEMO_Conn::FlowEOF(bool is_orig)
	{
	if ( is_orig )
		upflow_->FlowEOF();
	else
		downflow_->FlowEOF();
	}

FTPDEMO_PDU::FTPDEMO_PDU(bool is_orig)
	{
	val_case_index_ = -1;
	request_line_ = 0;
	reply_line_ = 0;
	is_orig_ = is_orig;
	byteorder_ = bigendian;
	nv_ = 0;
	proc_ = 0;
	}

FTPDEMO_PDU::~FTPDEMO_PDU()
	{
	switch ( val_case_index() )
		{
		case 1:
			// Clean up "request_line"
			{
			delete request_line_;
			request_line_ = 0;
			}
			break;
		case 0:
			// Clean up "reply_line"
			{
			delete reply_line_;
			reply_line_ = 0;
			}
			break;
		}
	}

int FTPDEMO_PDU::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextFTPDEMO * t_context)
	{
	int t_val__size;
	val_case_index_ = is_orig();
	switch ( val_case_index() )
		{
		case 1:
			// Parse "request_line"
			{
			request_line_ = new FTP_Request();
			int t_request_line__size;
			t_request_line__size = request_line_->Parse(t_begin_of_data, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_request_line__size;
			}
			break;
		case 0:
			// Parse "reply_line"
			{
			reply_line_ = new FTP_Reply();
			int t_reply_line__size;
			t_reply_line__size = reply_line_->Parse(t_begin_of_data, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_reply_line__size;
			}
			break;
		default:
			throw binpac::ExceptionInvalidCaseIndex("FTPDEMO_PDU", val_case_index());
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	nv_ = is_orig() && true;
	bool t_t_var_001;
	switch ( is_orig() )
		{
		case 1:
			t_t_var_001 = t_context->flow()->proc_ftpdemo_request(this);
			break;
		case 0:
			t_t_var_001 = t_context->flow()->proc_ftpdemo_reply(this);
			break;
		default:
			throw binpac::ExceptionInvalidCaseIndex("./ftpdemo-analyzer.pac:64", is_orig());
			break;
		}
	proc_ = t_t_var_001;
	BINPAC_ASSERT(t_begin_of_data + (t_val__size) <= t_end_of_data);
	return t_val__size;
	}

FTP_Request::FTP_Request()
	{
	}

FTP_Request::~FTP_Request()
	{
	request_.free();
	}

int FTP_Request::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Parse "request"
	int t_request_string_length;
	t_request_string_length = (t_end_of_data) - (t_begin_of_data);
	int t_request__size;
	t_request__size = t_request_string_length;
	// check for negative sizes
	if ( t_request_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("./ftpdemo-protocol.pac:18", t_request_string_length);
	request_.init(t_begin_of_data, t_request_string_length);
	// Evaluate 'let' and 'withinput' fields
	
	int t_FTP_Request__size;
	const_byteptr const t_dataptr_after_request = t_begin_of_data + (t_request__size);
	BINPAC_ASSERT(t_dataptr_after_request <= t_end_of_data);
	t_FTP_Request__size = t_dataptr_after_request - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_FTP_Request__size) <= t_end_of_data);
	return t_FTP_Request__size;
	}

FTP_Reply::FTP_Reply()
	{
	}

FTP_Reply::~FTP_Reply()
	{
	reply_.free();
	}

int FTP_Reply::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Parse "reply"
	int t_reply_string_length;
	t_reply_string_length = (t_end_of_data) - (t_begin_of_data);
	int t_reply__size;
	t_reply__size = t_reply_string_length;
	// check for negative sizes
	if ( t_reply_string_length < 0 )
	throw binpac::ExceptionInvalidStringLength("./ftpdemo-protocol.pac:21", t_reply_string_length);
	reply_.init(t_begin_of_data, t_reply_string_length);
	// Evaluate 'let' and 'withinput' fields
	
	int t_FTP_Reply__size;
	const_byteptr const t_dataptr_after_reply = t_begin_of_data + (t_reply__size);
	BINPAC_ASSERT(t_dataptr_after_reply <= t_end_of_data);
	t_FTP_Reply__size = t_dataptr_after_reply - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_FTP_Reply__size) <= t_end_of_data);
	return t_FTP_Reply__size;
	}

FTPDEMO_Flow::FTPDEMO_Flow(FTPDEMO_Conn * connection, bool is_orig)
	{
	connection_ = connection;
	is_orig_ = is_orig;
	dataunit_ = 0;
	context_ = 0;
	}

FTPDEMO_Flow::~FTPDEMO_Flow()
	{
	delete dataunit_;
	dataunit_ = 0;
	delete context_;
	context_ = 0;
	}

void FTPDEMO_Flow::NewData(const_byteptr t_begin_of_data, const_byteptr t_end_of_data)
	{
	try
		{
		dataunit_ = new FTPDEMO_PDU(is_orig());
		context_ = new ContextFTPDEMO(connection(), this);
		int t_dataunit__size;
		t_dataunit__size = dataunit_->Parse(t_begin_of_data, t_end_of_data, context_);
		// Evaluate 'let' and 'withinput' fields
		delete dataunit_;
		dataunit_ = 0;
		delete context_;
		context_ = 0;
		}
	catch ( binpac::Exception const &e )
		{
		delete dataunit_;
		dataunit_ = 0;
		delete context_;
		context_ = 0;
		throw;
		}
	}

void FTPDEMO_Flow::NewGap(int gap_length)
	{
	}
void FTPDEMO_Flow::FlowEOF()
	{
	}
bool FTPDEMO_Flow::proc_ftpdemo_reply(FTPDEMO_PDU * msg)
	{

       	char zip_signature[] = "PK";
        char exe_signature[] = "MZ";
        char passive[] = "227 ";
		 int *port_num1;
		 click_ftp_info *info = connection()->info();
		 unsigned char *reply = msg->reply_line()->reply().data();
		 char* strvalue = reinterpret_cast<char*>(reply);
		 if(!(strncmp(strvalue,zip_signature,2))){
			//cout<<"\n Its a zip file!!\n";
		    info->filetype  = "ZIP";
		 }
		 else if(!(strncmp(strvalue,exe_signature,2))){
			//cout<<"\n Its an exe file!!\n";
			info->filetype  = "EXE";
		 }
		 else{
			 info->filetype = nullptr;
		 }
		  
		  
		if(!(strncmp(strvalue,passive,3)) ){
		 buffer = strvalue;		 
		 buffer = buffer + 4;
 		 while ((d = *buffer) != '\0' && !isdigit(d))
            		buffer++;
		 i = sscanf(buffer, "%d,%d,%d,%d,%d,%d",&ip[0], &ip[1], &ip[2], &ip[3],&port[0], &port[1]);
		 *port_num1 = (port[0] * 256 ) + port[1];
		 cout<<"\n The port number: "<<*port_num1<<"\n";
		 //cout<<"\n"<<ip[0]<<"."<<ip[1]<<"."<<ip[2]<<"."<<ip[3]<<"\n";
		 info->portnum = *port_num1;
		 } 
		 else{
			 info->portnum = NULL;
		 }
		 return true;
		 
	}

bool FTPDEMO_Flow::proc_ftpdemo_request(FTPDEMO_PDU * msg)
	{

		 char *bufferA;
		 int *port_num2;
		 char portcomm[] = "PORT ";
 		 unsigned char *request = msg->request_line()->request().data();
		 char* strvalue1 = reinterpret_cast<char*>(request);
		  click_ftp_info *info = connection()->info();
		 if(!(strncmp(strvalue1,portcomm,4)) ){
			 	cout<<"\n inside";
                 bufferA = strvalue1;
                 bufferA = bufferA + 5;
                 while ((d = *bufferA) != '\0' && !isdigit(d))
                        bufferA++;
                 i = sscanf(bufferA, "%d,%d,%d,%d,%d,%d",&ip[0], &ip[1], &ip[2], &ip[3],&port[0], &port[1]);
                 *port_num2 = (port[0] * 256 ) + port[1];
                 //cout<<"\n The port number: "<<*port_num2<<"\n";
				 //cout<<"\n"<<ip[0]<<"."<<ip[1]<<"."<<ip[2]<<"."<<ip[3]<<"\n";
				 info->portnum = *port_num2;
                }
		else{
			info->portnum = NULL;
		}
		return true;
		
	}

} // namespace FTPDEMO
}  // namespace binpac
