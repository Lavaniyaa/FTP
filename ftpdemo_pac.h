// This file is automatically generated from ftpdemo.pac.

#ifndef ftpdemo_pac_h
#define ftpdemo_pac_h

#include <vector>

#include "binpac.h"


struct click_ftp_info{
	int portnum;
	char* filetype;
};


namespace binpac {

namespace FTPDEMO {
class ContextFTPDEMO;
class FTPDEMO_Conn;
class FTPDEMO_PDU;
class FTP_Request;
class FTP_Reply;
class FTPDEMO_Flow;
} // namespace FTPDEMO

namespace FTPDEMO {

class ContextFTPDEMO
{
public:
	ContextFTPDEMO(FTPDEMO_Conn * connection, FTPDEMO_Flow * flow);
	~ContextFTPDEMO();
	
	// Member access functions
	FTPDEMO_Conn * connection() const { return connection_; }
	FTPDEMO_Flow * flow() const { return flow_; }
	
protected:
	FTPDEMO_Conn * connection_;
	FTPDEMO_Flow * flow_;
};


class FTPDEMO_Conn : public binpac::ConnectionAnalyzer
{
public:
	FTPDEMO_Conn(click_ftp_info *info);
	~FTPDEMO_Conn();

	click_ftp_info * info_;
	
	// Member access functions
	FTPDEMO_Flow * upflow() const { return upflow_; }
	FTPDEMO_Flow * downflow() const { return downflow_; }
	click_ftp_info * info() const { return info_; }
	
	void NewData(bool is_orig, const_byteptr begin, const_byteptr end);
	void NewGap(bool is_orig, int gap_length);
	void FlowEOF(bool is_orig);
	
protected:
	FTPDEMO_Flow * upflow_;
	FTPDEMO_Flow * downflow_;
};


class FTPDEMO_PDU
{
public:
	FTPDEMO_PDU(bool is_orig);
	~FTPDEMO_PDU();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextFTPDEMO * t_context);
	
	// Member access functions
	int val_case_index() const	{ return val_case_index_; }
	FTP_Request * request_line() const
		{
		switch ( val_case_index() )
			{
			case 1:
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("./ftpdemo-protocol.pac:11:request_line", val_case_index(), "true");
				break;
			}
		return request_line_;
		}
	FTP_Reply * reply_line() const
		{
		switch ( val_case_index() )
			{
			case 0:
				break;  // OK
			default:
				throw binpac::ExceptionInvalidCase("./ftpdemo-protocol.pac:12:reply_line", val_case_index(), "false");
				break;
			}
		return reply_line_;
		}
	bool is_orig() const { return is_orig_; }
	int byteorder() const { return byteorder_; }
	bool nv() const { return nv_; }
	int proc() const { return proc_; }
	
protected:
	int val_case_index_;
	FTP_Request * request_line_;
	FTP_Reply * reply_line_;
	bool is_orig_;
	int byteorder_;
	bool nv_;
	int proc_;
};


class FTP_Request
{
public:
	FTP_Request();
	~FTP_Request();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data);
	
	// Member access functions
	bytestring const & request() const { return request_; }
	
protected:
	bytestring request_;
};


class FTP_Reply
{
public:
	FTP_Reply();
	~FTP_Reply();
	int Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data);
	
	// Member access functions
	bytestring const & reply() const { return reply_; }
	
protected:
	bytestring reply_;
};


class FTPDEMO_Flow : public binpac::FlowAnalyzer
{
public:
	FTPDEMO_Flow(FTPDEMO_Conn * connection, bool is_orig);
	~FTPDEMO_Flow();
	
	// Member access functions
	FTPDEMO_Conn * connection() const { return connection_; }
	bool is_orig() const { return is_orig_; }
	
	void NewData(const_byteptr t_begin_of_data, const_byteptr t_end_of_data);
	void NewGap(int gap_length);
	void FlowEOF();
	
	// Functions
	bool proc_ftpdemo_reply(FTPDEMO_PDU * msg);
	bool proc_ftpdemo_request(FTPDEMO_PDU * msg);
	
protected:
	FTPDEMO_PDU * dataunit_;
	ContextFTPDEMO * context_;
	
	// Additional members

		 char d;
                 char  *buffer;
                 int ip[4], port[2];
                 int i;
         	
	FTPDEMO_Conn * connection_;
	bool is_orig_;
};

} // namespace FTPDEMO
}  // namespace binpac
#endif /* ftpdemo_pac_h */
